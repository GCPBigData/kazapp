<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aprenda Java e Algoritmos | Kazapp</title>
    <link rel="stylesheet" href="../node_modules/foundation-sites/dist/css/foundation.min.css" />
    <link rel="stylesheet" href="../assets/foundation-icons/foundation-icons.css" />
    <link rel="stylesheet" href="../node_modules/highlight.js/styles/androidstudio.css" />
    <style>
        body { background-color: #FFF; padding: 5px; } 
    </style>
  </head>
  <body>      
    <!-- Set up Off-canvas -->
    <div class="off-canvas-wrapper"></div>
      
    <!-- MAIN:BEGIN -->
    <div>
        <!-- BREADCRUMBS:BEGIN -->
        <br />
        <nav role="navigation">
          <ul class="breadcrumbs">
            <li><a href="../index.html">Início</a></li>
            <li><a href="../index.html#big-o">Big-O</a></li>
            <li>O(1)</li>
          </ul>
        </nav>
        <!-- BREADCRUMBS:END -->
        
        <!-- PROGRESS:BEGIN -->
        <div class="primary progress" role="progressbar" tabindex="0" aria-valuenow="50" 
             aria-valuemin="0" aria-valuetext="50 percent" aria-valuemax="100">
          <div class="progress-meter" style="width: 50%">
            <p class="progress-meter-text">50%</p>
          </div>
        </div>
        <!-- PROGRESS:END -->
        
      <div class="pag1">
        <h2>Complexidade O(1)</h2>
        <p>A complexidade O(1) é a mais simples de entender, e será a sexta e última notação que estudaremos.</p>
        <p>Essa complexidade diz que para qualquer entrada de dados, seu processamento <b>sempre</b> será o mesmo, por isso ela também é conhecida como complexidade constante.</p>
        <p>Vamos a um exemplo, imagine que temos uma lista e queremos retornar um elemento dado seu índice. No Java por exemplo, essa operação sempre será o mesmo, pois listas nativas em Java conseguem obter um elemento diretamente dado o seu índice (sem a necessidade de percorrer pelos elementos).</p>
      </div>
        
      <div class="pag2">
        <h2>Complexidade O(1)</h2>    
        <p>Vamos ver como seria uma implementação de um exemplo na prática.</p>
          <p>No algoritmo a seguir, recebemos uma lista e um índice, e retornamos, e retornamos o elemento da lista para a posição solicitada.</p>
        <!-- CODE:BEGIN -->
        <div style="text-align: left"><pre><code>
private int executar(int[] numeros, int pos) {
    return numeros[pos];
}
        </code></pre></div>
        <!-- CODE:END -->
      </div>
          
      <div class="pag3">
        <h2>Vamos praticar?</h2>
        <p>Para você testar na prática e verificar a performance de um algoritmo O(1), vamos criar uma classe contendo um experimento que demonstrará a performance do algoritmo de busca por um elemento dado seu índice.</p>
        <p>Para isso crie um arquivo chamado <b>OrdemConstante.java</b> com o seguinte código:</p>
        <!-- CODE:BEGIN -->
        <div style="text-align: left"><pre><code>
public class OrdemConstante {

    private int executar(int[] numeros, int pos) {
        return numeros[pos];
    }

    private static void executarExperimento(OrdemConstante ordemConstante, int qtdNumeros, int posicao) {
        int[] numeros = new int[qtdNumeros];
        for (int i=0; i < qtdNumeros; i++) {
            numeros[i] = i;
        }
        long inicio = System.currentTimeMillis();
        System.out.println("Executando experimento para lista de " + qtdNumeros + " números.");
        ordemConstante.executar(numeros, posicao);
        long fim = System.currentTimeMillis();
        System.out.println("Experimento executado em " + (fim - inicio) + "ms\n");
    }

    public static void main(String[] args) {
        OrdemConstante ordemConstante = new OrdemConstante();
        executarExperimento(ordemConstante, 1, 0);
        executarExperimento(ordemConstante, 10, 5);
        executarExperimento(ordemConstante, 100, 50);
        executarExperimento(ordemConstante, 1000, 500);
        executarExperimento(ordemConstante, 10000, 5000);
        executarExperimento(ordemConstante, 100000, 50000);
        executarExperimento(ordemConstante, 1000000, 500000);
        executarExperimento(ordemConstante, 10000000, 5000000);
        executarExperimento(ordemConstante, 100000000, 50000000);
    }

}
        </code></pre></div>
        <!-- CODE:END -->
        <br />
        <p>O código acima chama o mesmo método estudado anteriormente, porém com diferentes valores de entrada, além de registrar o tempo de execução para cada chamada.</p>
      </div>
          
      <div class="pag4">
        <h2>Vamos praticar?</h2> 
        <p>Usando os conceitos aprendidos no primeiro módulo do curso, compile e execute a classe Java, você deverá ver no terminal algo similar a:</p> 
        <!-- CODE:BEGIN -->
        <div style="text-align: left"><pre><code>
Executando experimento para lista de 1 números.
Experimento executado em 0ms

Executando experimento para lista de 10 números.
Experimento executado em 0ms

Executando experimento para lista de 100 números.
Experimento executado em 0ms

Executando experimento para lista de 1000 números.
Experimento executado em 0ms

Executando experimento para lista de 10000 números.
Experimento executado em 0ms

Executando experimento para lista de 100000 números.
Experimento executado em 0ms

Executando experimento para lista de 1000000 números.
Experimento executado em 2ms

Executando experimento para lista de 10000000 números.
Experimento executado em 0ms

Executando experimento para lista de 100000000 números.
Experimento executado em 0ms
        </code></pre></div>
        <!-- CODE:END -->
          <br />
          <p>Verifique o tempo de execução para ver como a performance é constante.</p>  
          <p>Independente da quantidade de elementos na lista, o tempo de execução será praticamente o mesmo, pois o esforço para o processamento é o mesmo para qualquer valores de entrada.</p>
          <p>Aproveite também para testar a execução com outros valores, até estar confortável com o entendimento de execução desse algoritmo.</p>    
      </div>
        
        <!-- PAGINATION:BEGIN -->
        <br />
        <div style="text-align: center">
            <ul class="pagination" role="navigation" aria-label="Pagination">
              <li class="disabled anterior" style="cursor: pointer" onclick="Paginacao.paginaAnterior()">Anterior</li>
              <li class="proxima" style="cursor: pointer" onclick="Paginacao.proximaPagina()">Próximo</li>
            </ul>
        </div>
        <!-- PAGINATION:END -->
        
        <!-- END_CLASS:BEGIN -->
        <a class="button success expanded concluir" href="../index.html#big-o" onclick="return Persistencia.completar('.big-o-1', '');">Concluir lição</a>
        <a class="button secondary expanded sair" href="../index.html#big-o">Sair da lição</a>
        <!-- END_CLASS:END -->
        
    </div>
    <!-- MAIN:END -->

    <script src="../node_modules/jquery/dist/jquery.min.js"></script>
    <script src="../node_modules/foundation-sites/dist/js/foundation.min.js"></script>
    <script src="../assets/js/highlight.min.js"></script>
    <script src="../assets/js/menu-off-canvas.js"></script>
    <script src="../assets/js/paginacao.js"></script>
    <script src="../assets/js/localstorage-persistencia.js"></script>
    <script src="../assets/js/i18n-en_GB.js"></script>
    <script>
        $(document).foundation();
        hljs.initHighlightingOnLoad();
        Paginacao.init(4);
        Paginacao.paginar();
    </script>
  </body>
</html>
