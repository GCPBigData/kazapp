<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aprenda Java e Algoritmos | Kazapp</title>
    <link rel="stylesheet" href="../node_modules/foundation-sites/dist/css/foundation.min.css" />
    <link rel="stylesheet" href="../assets/foundation-icons/foundation-icons.css" />
    <link rel="stylesheet" href="../node_modules/highlight.js/styles/androidstudio.css" />
    <style>
        body { background-color: #FFF; padding: 5px; } 
    </style>
  </head>
  <body>      
    <!-- Set up Off-canvas -->
    <div class="off-canvas-wrapper"></div>
      
    <!-- MAIN:BEGIN -->
    <div>
        <!-- BREADCRUMBS:BEGIN -->
        <br />
        <nav role="navigation">
          <ul class="breadcrumbs">
            <li><a href="../index.html">Início</a></li>
            <li><a href="../index.html#algoritmos-busca-1">Algoritmos de busca 1</a></li>
            <li>Busca binária</li>
          </ul>
        </nav>
        <!-- BREADCRUMBS:END -->
        
        <!-- PROGRESS:BEGIN -->
        <div class="primary progress" role="progressbar" tabindex="0" aria-valuenow="50" 
             aria-valuemin="0" aria-valuetext="50 percent" aria-valuemax="100">
          <div class="progress-meter" style="width: 50%">
            <p class="progress-meter-text">50%</p>
          </div>
        </div>
        <!-- PROGRESS:END -->
        
      <div class="pag1">
        <h2>Busca binária</h2>
        <p>A busca binária é um algoritmo simples porém bastante eficiente, que faz uso do conceito dividir para conquistar para encontrar o valor a ser buscado.</p>
        <p>Ela possui um pré requisito, que é receber como entrada uma lista de dados previamente ordenada.</p>
        <p>Isso se faz necessário porque a busca binária segue dividindo uma lista ao meio, seguindo a busca apenas na metade a qual o elemento a ser encontrado poderá estar.</p>
        <p>Devido a essa estratégia, conseguimos realizar a busca em ordem logarítmica O(log n), que nos permite realizar buscas mesmo em uma lista com grande quantidade de dados com uma performance bastante satisfatória.</p>
        <p>Em sua implementação utilizamos um único laço <b>while</b> para iterar sob os items da lista, verificando e seguindo a cada iteração pela metade que pode conter o elemento procurado.</p>
        <p>Seu retorno será o índice da posição do elemento procurado na lista, ou "-1" caso ele não seja encontrado.</p>
        <div class="callout primary">
            A busca binária é um algoritmo de ordem O(log n), é de fácil implementação, e apresenta uma boa performance mesmo para busca em listas com muitos elementos na lista.
        </div>
      </div>
        
      <div class="pag2">
        <h2>Busca binária</h2>
        <p>Vamos ver através da animação a seguir como esse algoritmo se comporta:</p>
        <p><img src="../assets/img/busca-binaria.gif" alt="Busca binária" /></p>    
      </div>
          
      <div class="pag3">
        <h2>Vamos praticar?</h2>
        <p>Para você aprender a implementar um algoritmo de busca binária, vamos criar uma classe contendo sua implementação, e na sequência vamos entender o código fonte do mesmo.</p>
        <p>Para isso crie um arquivo chamado <b>BuscaBinaria.java</b> com o seguinte código:</p>
        <!-- CODE:BEGIN -->
        <div style="text-align: left"><pre><code>
public class BuscaBinaria {

    /**
     * Implementação do algoritmo de busca binária.
     * A busca binária possui performance de ordem O(log n).
     * Ela parte do princípio de que receberá uma lista ordenada.
     *
     * @param numeros - lista contendo os números utilizados para a busca.
     * @param numero - número a ser encontrado na lista.
     *
     * @return int - índice do número na lista, ou -1 caso não encontrado.
     */
    public int buscar(int[] numeros, int numero) {
        int indice = -1;
        if (numeros == null) {
            return indice;
        }

        int inicio = 0;
        int meio;
        int fim = numeros.length - 1;

        while (inicio <= fim) {
            meio = (inicio + fim) / 2;
            if (numeros[meio] < numero) {
                inicio = meio + 1;
            } else if (numeros[meio] > numero) {
                fim = meio - 1;
            } else if (numeros[meio] == numero) {
                indice = meio;
                break;
            }
        }

        return indice;
    }
}
        </code></pre></div>
        <!-- CODE:END -->
      </div>
          
      <div class="pag4">
        <h2>Entendo o código da busca binária</h2> 
        <p>O código acima é simples de entender, mas vamos a uma explicação do mesmo:</p>
        <ul>
          <li>O método <b>buscar</b> recebe dois parâmetros, a lista com o dados (ordenada) e o valor do elemento a ser procurado.</li>
          <li>Então verificamos se a lista possui elementos, e caso ela seja nula retornamos o valor "-1", que significa elemento não encontrado.</li>
          <li>Depois coemçamos a iterar sob os elementos da lista através do uso de um laço <b>while</b>.</li>
          <li>Para cada iteração verificamos qual o elemento referênte a posição central da lista.</li>
          <li>Após esse cálculo temos uma condicional que verifica se o elemento procurado é maior ou menor ao valor central, pois assim saberemos em qual metade da lista ele se encontra.</li>
          <li>Então marcamos o novo início e fim da lista, que passará a ser a metade a qual ele poderá ser encontrado.</li>
          <li>Existe também a verificação para ver se o elemento central é o que estamos procurando, pois caso positivo retornamos o índice referênte a ele na lista.</li>
          <li>Esse processo segue até que tenhamos 1 ou 2 elementos na lista, o que significa que vamos esgotando as opções através de divisões na lista até o encontrarmos.</li>
          <li>Obviamente se percorrermos toda a lista e não encontrarmos o elemento desejado, retornamos "-1", o que indica que ele não está presente na lista.</li>
        </ul>    
      </div>
          
      <div class="pag5">
        <h2>Validando nosso código</h2> 
        <p>Agora que você já entendeu como o algoritmo de busca binária funciona e é implementado, vamos criar uma classe de testes para validar sua implementação.</p>
        <p>Essa classe de teste utiliza como base o framework <a href="https://junit.org/junit5" target="_blank">JUnit</a> para sua execução.</p>
        <p>Para implementá-la, crie o arquivo <b>BuscaBinariaTest.java</b> com o seguinte código (que será explicado na sequência):</p>
        <!-- CODE:BEGIN -->
        <div style="text-align: left"><pre><code>
import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class BuscaBinariaTest {

    private static final int[] LISTA_NUMEROS = { 1, 2, 3, 5, 6, 9, 10, 20, 40, 100 };
    private static final int NUMERO_PRESENTE_LISTA = 10;
    private static final int NUMERO_NAO_PRESENTE_LISTA = 50;
    private static final int INDICE_NUMERO_EX_LISTA = 6;
    private static final int INDICE_NAO_ENCONTRADO = -1;

    private final BuscaBinaria buscaBinaria = new BuscaBinaria();

    @Test
    public void listaNulaTest() {
        int indice = buscaBinaria.buscar(null, NUMERO_PRESENTE_LISTA);

        assertEquals(INDICE_NAO_ENCONTRADO, indice);
    }

    @Test
    public void listaVaziaTest() {
        int indice = buscaBinaria.buscar(new int[0], NUMERO_PRESENTE_LISTA);

        assertEquals(INDICE_NAO_ENCONTRADO, indice);
    }

    @Test
    public void buscaComSucessoPrimeiraPosicaoTest() {
        int primeiroNumeroLista = LISTA_NUMEROS[0];
        int indice = buscaBinaria.buscar(LISTA_NUMEROS, primeiroNumeroLista);

        assertEquals(0, indice);
    }

    @Test
    public void buscaComSucessoTest() {
        int indice = buscaBinaria.buscar(LISTA_NUMEROS, NUMERO_PRESENTE_LISTA);

        assertEquals(INDICE_NUMERO_EX_LISTA, indice);
    }

    @Test
    public void buscaComSucessoUltimaPosicaoTest() {
        int indiceUltimoNumeroLista = LISTA_NUMEROS.length - 1;
        int ultimoNumeroLista = LISTA_NUMEROS[indiceUltimoNumeroLista];
        int indice = buscaBinaria.buscar(LISTA_NUMEROS, ultimoNumeroLista);

        assertEquals(indiceUltimoNumeroLista, indice);
    }

    @Test
    public void elementoNaoEncontrado() {
        int indice = buscaBinaria.buscar(LISTA_NUMEROS, NUMERO_NAO_PRESENTE_LISTA);

        assertEquals(INDICE_NAO_ENCONTRADO, indice);
    }
    
}
        </code></pre></div>
        <!-- CODE:END -->
     </div>
          
     <div class="pag6">
          <p>O código acima é bastante intuitivo. Ele inicia com a definição de algumas constantes que serão utilizadas nos testes, assim como a criação de uma instância da classe <b>BuscaBinaria</b> criada anteriormente.</p>  
          <p>Na sequência criamos uma série de métodos anotados com a anotação <b>@Test</b>, que representam os casos de testes no framework JUnit.</p>
          <p>Os nomes dos métodos são bem descritivos, e informam exatamente o que está sendo testado.</p>
          <p>Dentro de cada método fazemos uma chamada ao nosso método de busca, armazemando o seu valor de retorno.</p>
          <p>Por fim, com o auxílio do <b>assertEquals</b> do JUnit, verificamos se o retorno da busca possui o mesmo valor do valor esperado.</p>
      </div>
        
        <!-- PAGINATION:BEGIN -->
        <br />
        <div style="text-align: center">
            <ul class="pagination" role="navigation" aria-label="Pagination">
              <li class="disabled anterior" style="cursor: pointer" onclick="Paginacao.paginaAnterior()">Anterior</li>
              <li class="proxima" style="cursor: pointer" onclick="Paginacao.proximaPagina()">Próximo</li>
            </ul>
        </div>
        <!-- PAGINATION:END -->
        
        <!-- END_CLASS:BEGIN -->
        <a class="button success expanded concluir" href="../index.html#algoritmos-busca-1" onclick="return Persistencia.completar('.algoritmos-busca-1-busca-binaria', '');">Concluir lição</a>
        <a class="button secondary expanded sair" href="../index.html#algoritmos-busca-1">Sair da lição</a>
        <!-- END_CLASS:END -->
        
    </div>
    <!-- MAIN:END -->

    <script src="../node_modules/jquery/dist/jquery.min.js"></script>
    <script src="../node_modules/foundation-sites/dist/js/foundation.min.js"></script>
    <script src="../assets/js/highlight.min.js"></script>
    <script src="../assets/js/menu-off-canvas.js"></script>
    <script src="../assets/js/paginacao.js"></script>
    <script src="../assets/js/localstorage-persistencia.js"></script>
    <script src="../assets/js/i18n-en_GB.js"></script>
    <script>
        $(document).foundation();
        hljs.initHighlightingOnLoad();
        Paginacao.init(6);
        Paginacao.paginar();
    </script>
  </body>
</html>
